{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to BioKT-PLUMED-docs This website is a resource aimed at researchers from the BioKT lab to have working examples of different types of molecular dynamics simulations that can be run using Gromacs patched with PLUMED . These examples borrow extensively from the fantastic PLUMED masterclasses . However, what we show here is necessarily less exhaustive and simply intended to provide working examples of methods we routinely employ. Setup Simulation methods Umbrella sampling Metadynamics Simulations with multiple replicas Running simulations with PLUMED at DIPC","title":"Home"},{"location":"#welcome-to-biokt-plumed-docs","text":"This website is a resource aimed at researchers from the BioKT lab to have working examples of different types of molecular dynamics simulations that can be run using Gromacs patched with PLUMED . These examples borrow extensively from the fantastic PLUMED masterclasses . However, what we show here is necessarily less exhaustive and simply intended to provide working examples of methods we routinely employ.","title":"Welcome to BioKT-PLUMED-docs"},{"location":"#setup","text":"","title":"Setup"},{"location":"#simulation-methods","text":"Umbrella sampling Metadynamics Simulations with multiple replicas","title":"Simulation methods"},{"location":"#running-simulations-with-plumed-at-dipc","text":"","title":"Running simulations with PLUMED at DIPC"},{"location":"dipc/","text":"","title":"PLUMED@DIPC"},{"location":"metadynamics/","text":"","title":"Metadynamics"},{"location":"replicas/","text":"","title":"Multiple replicas"},{"location":"setup/","text":"Setting up PLUMED with Gromacs First of all you must patch the Gromacs code with PLUMED. There are multiple options available for you. Installing with conda If you only want a hassle-free installation to try things out, then you can simply use the pre-compiled versions made available by the PLUMED developers for their masterclasses. Here I follow the instructions from the first masterclass In the terminal, type $ conda create --name plumed-masterclass and then $ conda activate plumed-masterclass $ conda install -c conda-forge plumed py-plumed numpy pandas matplotlib notebook mdtraj mdanalysis git $ conda install --strict-channel-priority -c plumed/label/masterclass -c conda-forge gromacs Patch Gromacs with PLUMED First install PLUMED. In order to do this you will have to download and unzip the software $ wget https://github.com/plumed/plumed2/archive/refs/heads/master.zip $ unzip master.zip $ cd plumed2-master/ Then you will follow the usual steps to install software using Make $ ./configure --prefix=/usr/local $ make $ sudo make install You will also have to make sure that the installed libraries are visible in your path export LD_LIBRARY_PATH=/lib:/usr/lib:/usr/local/lib The next step is to install Gromacs. First download the code and unzip the package. In this case I am patching the 2021.6 version of Gromacs. wget ftp://ftp.gromacs.org/gromacs/gromacs-2021.6.tar.gz tar -xvf gromacs-2021.6.tar.gz The next thing I did was to check whether I could use Cmake to install with my desired options, in this case running with GPUs and compiling with MPI support cd gromacs-2021.6/ mkdir build cd build/ cmake .. -DGMX_BUILD_OWN_FFTW=ON -DREGRESSIONTEST_DOWNLOAD=ON -DGMX_MPI=on -DGMX_GPU=CUDA -DCMAKE_INSTALL_PREFIX=/opt/gromacs/2021.6 make Then comes the key step of running the plumed patch command cd .. plumed patch -p After that you can go back to your Gromacs install directory and finish the installation as usual cd build/ cmake .. -DGMX_BUILD_OWN_FFTW=ON -DREGRESSIONTEST_DOWNLOAD=ON -DGMX_MPI=on -DGMX_GPU=CUDA -DCMAKE_INSTALL_PREFIX=/opt/gromacs/2021.6 make sudo make install /opt/gromacs/2021.6/bin/gmx_mpi mdrun -h","title":"Setup"},{"location":"setup/#setting-up-plumed-with-gromacs","text":"First of all you must patch the Gromacs code with PLUMED. There are multiple options available for you.","title":"Setting up PLUMED with Gromacs"},{"location":"setup/#installing-with-conda","text":"If you only want a hassle-free installation to try things out, then you can simply use the pre-compiled versions made available by the PLUMED developers for their masterclasses. Here I follow the instructions from the first masterclass In the terminal, type $ conda create --name plumed-masterclass and then $ conda activate plumed-masterclass $ conda install -c conda-forge plumed py-plumed numpy pandas matplotlib notebook mdtraj mdanalysis git $ conda install --strict-channel-priority -c plumed/label/masterclass -c conda-forge gromacs","title":"Installing with conda"},{"location":"setup/#patch-gromacs-with-plumed","text":"First install PLUMED. In order to do this you will have to download and unzip the software $ wget https://github.com/plumed/plumed2/archive/refs/heads/master.zip $ unzip master.zip $ cd plumed2-master/ Then you will follow the usual steps to install software using Make $ ./configure --prefix=/usr/local $ make $ sudo make install You will also have to make sure that the installed libraries are visible in your path export LD_LIBRARY_PATH=/lib:/usr/lib:/usr/local/lib The next step is to install Gromacs. First download the code and unzip the package. In this case I am patching the 2021.6 version of Gromacs. wget ftp://ftp.gromacs.org/gromacs/gromacs-2021.6.tar.gz tar -xvf gromacs-2021.6.tar.gz The next thing I did was to check whether I could use Cmake to install with my desired options, in this case running with GPUs and compiling with MPI support cd gromacs-2021.6/ mkdir build cd build/ cmake .. -DGMX_BUILD_OWN_FFTW=ON -DREGRESSIONTEST_DOWNLOAD=ON -DGMX_MPI=on -DGMX_GPU=CUDA -DCMAKE_INSTALL_PREFIX=/opt/gromacs/2021.6 make Then comes the key step of running the plumed patch command cd .. plumed patch -p After that you can go back to your Gromacs install directory and finish the installation as usual cd build/ cmake .. -DGMX_BUILD_OWN_FFTW=ON -DREGRESSIONTEST_DOWNLOAD=ON -DGMX_MPI=on -DGMX_GPU=CUDA -DCMAKE_INSTALL_PREFIX=/opt/gromacs/2021.6 make sudo make install /opt/gromacs/2021.6/bin/gmx_mpi mdrun -h","title":"Patch Gromacs with PLUMED"},{"location":"umbrella/","text":"Umbrella sampling with PLUMED Alanine dipeptide in vacuum First of all, we will download the data required to run the calculations, which should be in the data/umbrella folder of this repository. It should contain the following files $ ls data/umbrella/ reference.pdb topolA.tpr topolB.tpr Using the typical Gromacs syntax, you could use these tpr files to run MD simulations using $ gmx mdrun -plumed plumed.dat -s topolA.tpr -nsteps 200000 -x traj_unbiased.xtc This will result in an unbiased simulation trajectory of the alanine dipeptide. When we run simulations with the PLUMED we will use an additional flag -plumed that points to the unique input required to bias the simulations. Below, you can find an example input file to estimate the values of the \\( \\phi \\) and \\( \\psi \\) dihedrals and histogram their values. MOLINFO STRUCTURE=reference.pdb phi: TORSION ATOMS=@phi-2 psi: TORSION ATOMS=@psi-2 # make histograms hhphi: HISTOGRAM ARG=phi STRIDE=100 GRID_MIN=-pi GRID_MAX=pi GRID_BIN=600 BANDWIDTH=0.05 ffphi: CONVERT_TO_FES GRID=hhphi DUMPGRID GRID=ffphi FILE=fes_phi.dat STRIDE=200000 hhpsi: HISTOGRAM ARG=psi STRIDE=100 GRID_MIN=-pi GRID_MAX=pi GRID_BIN=600 BANDWIDTH=0.05 ffpsi: CONVERT_TO_FES GRID=hhpsi DUMPGRID GRID=ffpsi FILE=fes_psi.dat STRIDE=200000 PRINT ARG=phi,psi FILE=colvar.dat STRIDE=100 Note that we are using a number of actions ( TORSION , HISTOGRAM and DUMPGRID , to name a few). You should familiarize yourself with their syntax . Introducing an umbrella bias in this script is exceedingly easy. It just requires adding an extra line to the script. For example, to restrain the simulation with a harmonic potential at 0 radians with a spring constant of 200, we would write # add restraining potential bb: RESTRAINT ARG=phi KAPPA=200.0 AT=0 Of course, we will be interested in running multiple window umbrella sampling, and hence the structure of our directory should change with as many plumed files as umbrellas windows. To generate 32 PLUMED input files, we can use the following Python script: at=np.linspace(-np.pi,np.pi,33)[:-1] print(at) for i in range(32): with open(\"plumed_\" + str(i) + \".dat\",\"w\") as f: print(\"\"\" # vim:ft=plumed MOLINFO STRUCTURE=reference.pdb phi: TORSION ATOMS=@phi-2 psi: TORSION ATOMS=@psi-2 bb: RESTRAINT ARG=phi KAPPA=200.0 AT={} PRINT ARG=phi,psi,bb.bias FILE=colvar_multi_{}.dat STRIDE=100 \"\"\".format(at[i],i),file=f) And then we will run the 32 simulations $> for i in $(seq 0 1 31); do gmx mdrun -plumed plumed_${i}.dat -s topolA.tpr -nsteps 200000 -x traj_comp_${i}.xtc done The result from this will be a dataset of 32 simulations, all initialized at the same conformation, but with umbrella potentials that will bias the sampling to different regions of conformational space. After completion of the runs, we must analyze the resulting trajectories. In order to do that we concatenate the trajectories $ gmx trjcat -cat -f `for i in $(seq 0 1 31); do echo \"traj_comp_${i}.xtc\"; done` -o traj_multi_cat.xtc Then, we analyze them using plumed driver: $ for i in $(seq 0 1 31) do plumed driver --plumed plumed_${i}.dat --ixtc traj_multi_cat.xtc --trajectory-stride 100 done To visualize the output of the simulations, we can read the colvar_multi_\\*.dat files and see what region of the Ramachandran map has been sampled by each of the runs. Using a Jupyter-notebook we can run the following import plumed import wham col=[] for i in range(32): col.append(plumed.read_as_pandas(\"colvar_multi_\" + str(i)+\".dat\")) bias = np.zeros((len(col[0][\"bb.bias\"]),32)) for i in range(32): bias[:,i] = col[i][\"bb.bias\"][-len(bias):] w = wham.wham(bias,T=kBT) colvar = col[0] colvar[\"logweights\"] = w[\"logW\"] plumed.write_pandas(colvar,\"bias_multi.dat\") We then write a file called plumed_multi.dat to obtain reweighted free energy surfaces. The file should look as follows: # vim:ft=plumed phi: READ FILE=bias_multi.dat VALUES=phi IGNORE_TIME psi: READ FILE=bias_multi.dat VALUES=psi IGNORE_TIME lw: READ FILE=bias_multi.dat VALUES=logweights IGNORE_TIME hhphi: HISTOGRAM ARG=phi GRID_MIN=-pi GRID_MAX=pi GRID_BIN=600 BANDWIDTH=0.05 ffphi: CONVERT_TO_FES GRID=hhphi DUMPGRID GRID=ffphi FILE=fes_phi_cat.dat hhpsi: HISTOGRAM ARG=psi GRID_MIN=-pi GRID_MAX=pi GRID_BIN=600 BANDWIDTH=0.05 ffpsi: CONVERT_TO_FES GRID=hhpsi DUMPGRID GRID=ffpsi FILE=fes_psi_cat.dat hhphir: HISTOGRAM ARG=phi GRID_MIN=-pi GRID_MAX=pi GRID_BIN=600 BANDWIDTH=0.05 LOGWEIGHTS=lw ffphir: CONVERT_TO_FES GRID=hhphir DUMPGRID GRID=ffphir FILE=fes_phi_catr.dat hhpsir: HISTOGRAM ARG=psi GRID_MIN=-pi GRID_MAX=pi GRID_BIN=600 BANDWIDTH=0.05 LOGWEIGHTS=lw ffpsir: CONVERT_TO_FES GRID=hhpsir DUMPGRID GRID=ffpsir FILE=fes_psi_catr.dat This script is again read by plumed driver, and from this program we get our outputs. Clearly, using umbrella sampling we have been able to cover much more ground for our reaction coordinates, while obtaining a very consistent PMF in the regions that actually matter. One of the assignments in the masterclass is to run from a different initial state. I try this repeating what we\u2019ve done from topolA.tpr: $> for i in $(seq 0 1 31); do gmx mdrun -plumed plumed_${i}.dat -s topolB.tpr -nsteps 200000 -x traj_comp_B_${i}.xtc; done $ gmx trjcat -cat -f for i in $(seq 0 1 31); do echo \"traj_comp_B_${i}.xtc\"; done -o traj_multi_B_cat.xtc I generate the corresponding plumed_B_${i}.dat files for plumed driver and run: $ for i in $(seq 0 1 31) do plumed driver --plumed plumed_B_${i}.dat --ixtc traj_multi_B_cat.xtc --trajectory-stride 100 done Below I compare the sampling from topolA (left) and from topolB (right). There are very interesting differences, particularly with respect to the positive phi region, which is very much not sampled when we start to run dynamics from the topolB. The results are interesting as we find that there certainly is some influence in the initial conditions for umbrella sampling.","title":"Umbrella sampling"},{"location":"umbrella/#umbrella-sampling-with-plumed","text":"","title":"Umbrella sampling with PLUMED"},{"location":"umbrella/#alanine-dipeptide-in-vacuum","text":"First of all, we will download the data required to run the calculations, which should be in the data/umbrella folder of this repository. It should contain the following files $ ls data/umbrella/ reference.pdb topolA.tpr topolB.tpr Using the typical Gromacs syntax, you could use these tpr files to run MD simulations using $ gmx mdrun -plumed plumed.dat -s topolA.tpr -nsteps 200000 -x traj_unbiased.xtc This will result in an unbiased simulation trajectory of the alanine dipeptide. When we run simulations with the PLUMED we will use an additional flag -plumed that points to the unique input required to bias the simulations. Below, you can find an example input file to estimate the values of the \\( \\phi \\) and \\( \\psi \\) dihedrals and histogram their values. MOLINFO STRUCTURE=reference.pdb phi: TORSION ATOMS=@phi-2 psi: TORSION ATOMS=@psi-2 # make histograms hhphi: HISTOGRAM ARG=phi STRIDE=100 GRID_MIN=-pi GRID_MAX=pi GRID_BIN=600 BANDWIDTH=0.05 ffphi: CONVERT_TO_FES GRID=hhphi DUMPGRID GRID=ffphi FILE=fes_phi.dat STRIDE=200000 hhpsi: HISTOGRAM ARG=psi STRIDE=100 GRID_MIN=-pi GRID_MAX=pi GRID_BIN=600 BANDWIDTH=0.05 ffpsi: CONVERT_TO_FES GRID=hhpsi DUMPGRID GRID=ffpsi FILE=fes_psi.dat STRIDE=200000 PRINT ARG=phi,psi FILE=colvar.dat STRIDE=100 Note that we are using a number of actions ( TORSION , HISTOGRAM and DUMPGRID , to name a few). You should familiarize yourself with their syntax . Introducing an umbrella bias in this script is exceedingly easy. It just requires adding an extra line to the script. For example, to restrain the simulation with a harmonic potential at 0 radians with a spring constant of 200, we would write # add restraining potential bb: RESTRAINT ARG=phi KAPPA=200.0 AT=0 Of course, we will be interested in running multiple window umbrella sampling, and hence the structure of our directory should change with as many plumed files as umbrellas windows. To generate 32 PLUMED input files, we can use the following Python script: at=np.linspace(-np.pi,np.pi,33)[:-1] print(at) for i in range(32): with open(\"plumed_\" + str(i) + \".dat\",\"w\") as f: print(\"\"\" # vim:ft=plumed MOLINFO STRUCTURE=reference.pdb phi: TORSION ATOMS=@phi-2 psi: TORSION ATOMS=@psi-2 bb: RESTRAINT ARG=phi KAPPA=200.0 AT={} PRINT ARG=phi,psi,bb.bias FILE=colvar_multi_{}.dat STRIDE=100 \"\"\".format(at[i],i),file=f) And then we will run the 32 simulations $> for i in $(seq 0 1 31); do gmx mdrun -plumed plumed_${i}.dat -s topolA.tpr -nsteps 200000 -x traj_comp_${i}.xtc done The result from this will be a dataset of 32 simulations, all initialized at the same conformation, but with umbrella potentials that will bias the sampling to different regions of conformational space. After completion of the runs, we must analyze the resulting trajectories. In order to do that we concatenate the trajectories $ gmx trjcat -cat -f `for i in $(seq 0 1 31); do echo \"traj_comp_${i}.xtc\"; done` -o traj_multi_cat.xtc Then, we analyze them using plumed driver: $ for i in $(seq 0 1 31) do plumed driver --plumed plumed_${i}.dat --ixtc traj_multi_cat.xtc --trajectory-stride 100 done To visualize the output of the simulations, we can read the colvar_multi_\\*.dat files and see what region of the Ramachandran map has been sampled by each of the runs. Using a Jupyter-notebook we can run the following import plumed import wham col=[] for i in range(32): col.append(plumed.read_as_pandas(\"colvar_multi_\" + str(i)+\".dat\")) bias = np.zeros((len(col[0][\"bb.bias\"]),32)) for i in range(32): bias[:,i] = col[i][\"bb.bias\"][-len(bias):] w = wham.wham(bias,T=kBT) colvar = col[0] colvar[\"logweights\"] = w[\"logW\"] plumed.write_pandas(colvar,\"bias_multi.dat\") We then write a file called plumed_multi.dat to obtain reweighted free energy surfaces. The file should look as follows: # vim:ft=plumed phi: READ FILE=bias_multi.dat VALUES=phi IGNORE_TIME psi: READ FILE=bias_multi.dat VALUES=psi IGNORE_TIME lw: READ FILE=bias_multi.dat VALUES=logweights IGNORE_TIME hhphi: HISTOGRAM ARG=phi GRID_MIN=-pi GRID_MAX=pi GRID_BIN=600 BANDWIDTH=0.05 ffphi: CONVERT_TO_FES GRID=hhphi DUMPGRID GRID=ffphi FILE=fes_phi_cat.dat hhpsi: HISTOGRAM ARG=psi GRID_MIN=-pi GRID_MAX=pi GRID_BIN=600 BANDWIDTH=0.05 ffpsi: CONVERT_TO_FES GRID=hhpsi DUMPGRID GRID=ffpsi FILE=fes_psi_cat.dat hhphir: HISTOGRAM ARG=phi GRID_MIN=-pi GRID_MAX=pi GRID_BIN=600 BANDWIDTH=0.05 LOGWEIGHTS=lw ffphir: CONVERT_TO_FES GRID=hhphir DUMPGRID GRID=ffphir FILE=fes_phi_catr.dat hhpsir: HISTOGRAM ARG=psi GRID_MIN=-pi GRID_MAX=pi GRID_BIN=600 BANDWIDTH=0.05 LOGWEIGHTS=lw ffpsir: CONVERT_TO_FES GRID=hhpsir DUMPGRID GRID=ffpsir FILE=fes_psi_catr.dat This script is again read by plumed driver, and from this program we get our outputs. Clearly, using umbrella sampling we have been able to cover much more ground for our reaction coordinates, while obtaining a very consistent PMF in the regions that actually matter. One of the assignments in the masterclass is to run from a different initial state. I try this repeating what we\u2019ve done from topolA.tpr: $> for i in $(seq 0 1 31); do gmx mdrun -plumed plumed_${i}.dat -s topolB.tpr -nsteps 200000 -x traj_comp_B_${i}.xtc; done $ gmx trjcat -cat -f for i in $(seq 0 1 31); do echo \"traj_comp_B_${i}.xtc\"; done -o traj_multi_B_cat.xtc I generate the corresponding plumed_B_${i}.dat files for plumed driver and run: $ for i in $(seq 0 1 31) do plumed driver --plumed plumed_B_${i}.dat --ixtc traj_multi_B_cat.xtc --trajectory-stride 100 done Below I compare the sampling from topolA (left) and from topolB (right). There are very interesting differences, particularly with respect to the positive phi region, which is very much not sampled when we start to run dynamics from the topolB. The results are interesting as we find that there certainly is some influence in the initial conditions for umbrella sampling.","title":"Alanine dipeptide in vacuum"}]}